# RF Listener

Проект демонстрирует, как компьютер может общаться с внешними устройствами через последовательный порт.
Он построен по слоям: от работы с портом до высокоуровневых команд "инверторов". Код и комментарии рассчитаны на
тех, кто впервые сталкивается с формированием и передачей собственных пакетов данных.

## Каталоги и файлы

- `Lib/jSerialComm-2.11.2.jar` – библиотека для доступа к COM‑портам.
- `src/RF` – исходный код.
  - `Main.java` – точка входа: запускает окно `MainUI`.
  - `MainUI.java` – графический интерфейс на Swing.
    Пользователь выбирает порт, скорость, битность, четность, стоп‑биты и одну из функций класса `Inverters`.
  - `cMAC.java` – "мини‑MAC‑слой". Управляет портом, собирает пакеты и раздает их обработчикам.
  - `ARP.java` – модуль обнаружения устройств (`PING`, выдача собственного адреса, очистка устаревших записей).
  - `Inverters.java` – прикладные команды к удаленным устройствам.
  - `Address.java`, `PacketHandler.java` – вспомогательные классы для адресов и обработчиков пакетов.
- `bin/` – каталог для скомпилированных классов (создается вручную).

## Что происходит при запуске

1. **Выбор параметров соединения.**
   `MainUI` запрашивает список доступных портов через `cMAC.getAvailablePorts` и показывает его в комбобоксе.
   После выбора параметров нажимается кнопка "Подключиться".

2. **Создание канального уровня.**
   `MainUI` создает объект `cMAC`, который:
   - открывает выбранный порт и настраивает его параметры;
   - запускает поток `run()` для отправки пакетов из очереди `sendQueue`;
   - регистрирует обработчики: `ARP` и `Inverters`.

3. **Формирование пакета.**
   При вызове команды из `Inverters` данные складываются в массив:

   ```text
   +----------------+----------------+------------------+
   | dest (4 байта) | src (4 байта)  | payload (N байт) |
   +----------------+----------------+------------------+
   ```
   Первый байт полезной нагрузки (`payload[0]`) – тип пакета. По нему `cMAC` решает,
   какому обработчику его передать.

4. **Передача.**
   Сформированный пакет помещается в `sendQueue`. Поток `cMAC.run()` извлекает его и
   отправляет в порт `SerialPort.writeBytes`.

5. **Прием.**
   Когда данные поступают из порта, срабатывает слушатель `SerialPortDataListener`.
   Он считывает весь буфер, выводит содержимое в консоль и передает байты в `handlePacket`.

6. **Маршрутизация.**
   `cMAC.handlePacket` извлекает адрес отправителя и тип пакета, затем отдает payload
   соответствующему обработчику (`ARP` или `Inverters`).

7. **ARP.**
   Отвечает на запросы MAC‑адреса и `PING`, ведет таблицу обнаруженных устройств и
   удаляет записи, которые "протухли".

8. **Команды инверторов.**
   Класс `Inverters` использует схему "запрос‑ожидание":
   - создается `CompletableFuture`, который ждет ответ не дольше 1 секунды;
   - `handlePacket` завершает ожидающий `Future` при получении ответа или сообщает о таймауте.

## Сборка и запуск

```bash
javac -d bin -cp Lib/jSerialComm-2.11.2.jar src/RF/*.java
java -cp Lib/jSerialComm-2.11.2.jar:bin RF.Main
```

Если компилятор выводит `error: release version 23 not supported`,
уберите параметр `--release 23` из команды или установите более свежий JDK.

> В средах без графической подсистемы запуск приведет к `HeadlessException`.
